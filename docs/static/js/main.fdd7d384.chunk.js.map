{"version":3,"sources":["components/libgif.js","components/Results.js","components/searchGiphy.js","components/Gif.js","components/GifDisplay.js","components/GifBar.js","constants.js","components/VideosListElement.js","components/VideosList.js","App.js","serviceWorker.js","index.js"],"names":["factory","bitsToNum","ba","reduce","s","n","byteToBitArr","bite","a","i","push","Stream","data","this","len","length","pos","readByte","Error","Uint8Array","charCodeAt","readBytes","bytes","read","String","fromCharCode","readUnsigned","parseGIF","st","handler","parseCT","entries","ct","readSubBlocks","size","parseImg","img","leftPos","topPos","width","height","bits","lctFlag","shift","interlaced","sorted","reserved","splice","lctSize","lct","lzwMinCodeSize","lzwData","pixels","minCodeSize","code","last","readCode","output","clearCode","eoiCode","codeSize","dict","clear","concat","apply","lzwDecode","newPixels","Array","rows","cpRow","toRow","fromRow","fromPixels","slice","offsets","steps","pass","deinterlace","parseBlock","block","sentinel","type","label","extType","disposalMethod","userInput","transparencyGiven","delayTime","transparencyIndex","terminator","gce","parseGCExt","comment","com","parseComExt","ptHeader","ptData","pte","parsePTExt","identifier","authCode","unknown","iterations","app","NETSCAPE","parseNetscapeExt","appData","parseUnknownAppExt","parseAppExt","parseUnknownExt","parseExt","eof","toString","setTimeout","hdr","sig","ver","gctFlag","colorRes","gctSize","bgColor","pixelAspectRatio","gct","parseHeader","opts","stream","options","vp_l","vp_t","vp_w","vp_h","c_w","c_h","is_vp","loadError","loading","transparency","delay","disposalRestoreFromIdx","lastDisposalMethod","frame","lastImg","playing","ctx_scaled","frames","frameOffsets","gif","auto_play","getAttribute","canvas","ctx","toolbar","tmpCanvas","onEndListener","hasOwnProperty","on_end","loopDelay","loop_delay","overrideLoopMode","loop_mode","drawWhileLoading","draw_while_loading","showProgressBar","show_progress_bar","progressBarHeight","progressbar_height","progressBarBackgroundColor","progressbar_background_color","progressBarForegroundColor","progressbar_foreground_color","doParse","err","doLoadError","setSizes","w","h","get_canvas_scale","style","minWidth","getContext","setTransform","doShowProgress","draw","mid","top","fillStyle","fillRect","originOfError","strokeStyle","lineWidth","moveTo","lineTo","stroke","pushFrame","getImageData","x","y","player","iterationCount","stepFrame","amount","putFrame","step","stepping","completeLoop","doStep","offset","parseInt","putImageData","globalCompositeOperation","drawImage","init","scale","play","pause","move_relative","current_frame","move_to","frame_idx","doDecodeProgress","doNothing","withProgress","fn","_hdr","currIdx","clearRect","imgData","forEach","pixel","load_callback","parent","parentNode","div","document","createElement","className","appendChild","insertBefore","removeChild","initialized","max_width","load_setup","callback","get_playing","get_canvas","get_loading","get_auto_play","get_length","get_current_frame","load_url","src","XMLHttpRequest","open","overrideMimeType","responseType","setRequestHeader","onloadstart","onload","e","status","response","indexOf","onprogress","lengthComputable","loaded","total","onerror","send","load","load_raw","arr","set_frame_offset","module","exports","Results","_this","react_default","props","searchResults","map","item","index","key","images","fixed_height_small","url","onClick","onGifClick","Component","searchGifs","query","fetch","cors","cache","then","json","SearchGiphy","Object","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","handleSearch","state","gifs","setState","results","handleChange","event","target","value","searchTimeoutId","clearTimeout","queryInput","React","createRef","prevProps","prevState","current","focus","clearInterval","intervalId","placeholder","onChange","ref","src_components_Results","previouslyUsedGifs","Gif","onEnd","duration","isReady","element","timeoutId","_this2","wrapper","SuperGif","loop","_this3","alt","defaultProps","autoPlay","GifDisplay","components_Gif","left","positionX","positionY","visibility","GifBar","showMarkers","timeFraction","marginLeft","SERVER_ADDRESS","VIDEO_INFO_ADDRESS","PopulatedVideoInfo","backgroundImage","videoInfo","thumbnail_url","window","location","videoId","title","VideosListElement","error","VideosListElement_PopulatedVideoInfo","VideosList","hideList","preventDefault","onHide","videoIds","from","Set","video","filter","visible","href","src_components_VideosListElement","App","handleEsc","showGifSearch","handleDocumentClick","searchDiv","contains","serverGifToLocal","gifId","timestamp","fracX","fracY","serverId","_id","fetchGifs","getVideoDuration","internalPlayer","getDuration","onPlayerReady","setInterval","timer","Promise","all","_ref","_ref2","slicedToArray","computeGifPositions","sort","b","videoDuration","onPlayerStateChange","videoPlaying","gifBarTimeoutId","showGifBar","onMouseMove","getCurrentTime","time","currentVideoTime","_ref3","anythingChanged","newGifs","Math","abs","assign","gifEnded","_ref4","gif_index","findIndex","stateGif","toConsumableArray","toggleGifSearch","_ref5","closeGifSearch","handleCancel","newGif","addNewGif","_ref6","includes","localStorage","setItem","JSON","stringify","pauseVideo","postNewGif","gifInfo","method","headers","Content-Type","body","gifTimestamp","getRealVideoDimensions","videoRect","ReactDOM","findDOMNode","children","getBoundingClientRect","min","gifList","realDimensions","max","objectSpread","updateGifPositions","_ref7","onWindowResize","saveNewGif","id","toSave","newGifX","newGifY","newGifRnd","newGifDuration","newGifSize","urlParams","get","parse","getItem","showAddGif","showVideosList","addEventListener","removeEventListener","src_components_VideosList","data-toggle","YouTube","playerVars","autoplay","onReady","onStateChange","lib","bounds","lockAspectRatio","onDragStop","d","onResize","src_components_GifBar","components_searchGiphy","components_GifDisplay","Boolean","hostname","match","URLSearchParams","search","render","src_App_0","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.fdd7d384.chunk.js","sourcesContent":["/*\n\tSuperGif\n\n\tExample usage:\n\n\t\t<img src=\"./example1_preview.gif\" rel:animated_src=\"./example1.gif\" width=\"360\" height=\"360\" rel:auto_play=\"1\" />\n\n\t\t<script type=\"text/javascript\">\n\t\t\t$$('img').each(function (img_tag) {\n\t\t\t\tif (/.*\\.gif/.test(img_tag.src)) {\n\t\t\t\t\tvar rub = new SuperGif({ gif: img_tag } );\n\t\t\t\t\trub.load();\n\t\t\t\t}\n\t\t\t});\n\t\t</script>\n\n\tImage tag attributes:\n\n\t\trel:animated_src -\tIf this url is specified, it's loaded into the player instead of src.\n\t\t\t\t\t\t\tThis allows a preview frame to be shown until animated gif data is streamed into the canvas\n\n\t\trel:auto_play -\t\tDefaults to 1 if not specified. If set to zero, a call to the play() method is needed\n\n\tConstructor options args\n\n\t\tgif \t\t\t\tRequired. The DOM element of an img tag.\n\t\tloop_mode\t\t\tOptional. Setting this to false will force disable looping of the gif.\n\t\tauto_play \t\t\tOptional. Same as the rel:auto_play attribute above, this arg overrides the img tag info.\n\t\tmax_width\t\t\tOptional. Scale images over max_width down to max_width. Helpful with mobile.\n \t\ton_end\t\t\t\tOptional. Add a callback for when the gif reaches the end of a single loop (one iteration). The first argument passed will be the gif HTMLElement.\n\t\tloop_delay\t\t\tOptional. The amount of time to pause (in ms) after each single loop (iteration).\n\t\tdraw_while_loading\tOptional. Determines whether the gif will be drawn to the canvas whilst it is loaded.\n\t\tshow_progress_bar\tOptional. Only applies when draw_while_loading is set to true.\n\n\tInstance methods\n\n\t\t// loading\n\t\tload( callback )\t\tLoads the gif specified by the src or rel:animated_src sttributie of the img tag into a canvas element and then calls callback if one is passed\n\t\tload_url( src, callback )\tLoads the gif file specified in the src argument into a canvas element and then calls callback if one is passed\n\n\t\t// play controls\n\t\tplay -\t\t\t\tStart playing the gif\n\t\tpause -\t\t\t\tStop playing the gif\n\t\tmove_to(i) -\t\tMove to frame i of the gif\n\t\tmove_relative(i) -\tMove i frames ahead (or behind if i < 0)\n\n\t\t// getters\n\t\tget_canvas\t\t\tThe canvas element that the gif is playing in. Handy for assigning event handlers to.\n\t\tget_playing\t\t\tWhether or not the gif is currently playing\n\t\tget_loading\t\t\tWhether or not the gif has finished loading/parsing\n\t\tget_auto_play\t\tWhether or not the gif is set to play automatically\n\t\tget_length\t\t\tThe number of frames in the gif\n\t\tget_current_frame\tThe index of the currently displayed frame of the gif\n\n\t\tFor additional customization (viewport inside iframe) these params may be passed:\n\t\tc_w, c_h - width and height of canvas\n\t\tvp_t, vp_l, vp_ w, vp_h - top, left, width and height of the viewport\n\n\t\tA bonus: few articles to understand what is going on\n\t\t\thttp://enthusiasms.org/post/16976438906\n\t\t\thttp://www.matthewflickinger.com/lab/whatsinagif/bits_and_bytes.asp\n\t\t\thttp://humpy77.deviantart.com/journal/Frame-Delay-Times-for-Animated-GIFs-214150546\n\n*/\n(function (root, factory) {\n    let define = 0;\n    if (typeof define === 'function' && define.amd) {\n        define([], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory();\n    } else {\n        root.SuperGif = factory();\n    }\n}(this, function () {\n    // Generic functions\n    var bitsToNum = function (ba) {\n        return ba.reduce(function (s, n) {\n            return s * 2 + n;\n        }, 0);\n    };\n\n    var byteToBitArr = function (bite) {\n        var a = [];\n        for (var i = 7; i >= 0; i--) {\n            a.push( !! (bite & (1 << i)));\n        }\n        return a;\n    };\n\n    // Stream\n    /**\n     * @constructor\n     */\n    // Make compiler happy.\n    var Stream = function (data) {\n        this.data = data;\n        this.len = this.data.length;\n        this.pos = 0;\n\n        this.readByte = function () {\n            if (this.pos >= this.data.length) {\n                throw new Error('Attempted to read past end of stream.');\n            }\n            if (data instanceof Uint8Array)\n                return data[this.pos++];\n            else\n                return data.charCodeAt(this.pos++) & 0xFF;\n        };\n\n        this.readBytes = function (n) {\n            var bytes = [];\n            for (var i = 0; i < n; i++) {\n                bytes.push(this.readByte());\n            }\n            return bytes;\n        };\n\n        this.read = function (n) {\n            var s = '';\n            for (var i = 0; i < n; i++) {\n                s += String.fromCharCode(this.readByte());\n            }\n            return s;\n        };\n\n        this.readUnsigned = function () { // Little-endian.\n            var a = this.readBytes(2);\n            return (a[1] << 8) + a[0];\n        };\n    };\n\n    var lzwDecode = function (minCodeSize, data) {\n        // TODO: Now that the GIF parser is a bit different, maybe this should get an array of bytes instead of a String?\n        var pos = 0; // Maybe this streaming thing should be merged with the Stream?\n        var readCode = function (size) {\n            var code = 0;\n            for (var i = 0; i < size; i++) {\n                if (data.charCodeAt(pos >> 3) & (1 << (pos & 7))) {\n                    code |= 1 << i;\n                }\n                pos++;\n            }\n            return code;\n        };\n\n        var output = [];\n\n        var clearCode = 1 << minCodeSize;\n        var eoiCode = clearCode + 1;\n\n        var codeSize = minCodeSize + 1;\n\n        var dict = [];\n\n        var clear = function () {\n            dict = [];\n            codeSize = minCodeSize + 1;\n            for (var i = 0; i < clearCode; i++) {\n                dict[i] = [i];\n            }\n            dict[clearCode] = [];\n            dict[eoiCode] = null;\n\n        };\n\n        var code;\n        var last;\n\n        while (true) {\n            last = code;\n            code = readCode(codeSize);\n\n            if (code === clearCode) {\n                clear();\n                continue;\n            }\n            if (code === eoiCode) break;\n\n            if (code < dict.length) {\n                if (last !== clearCode) {\n                    dict.push(dict[last].concat(dict[code][0]));\n                }\n            }\n            else {\n                if (code !== dict.length) throw new Error('Invalid LZW code.');\n                dict.push(dict[last].concat(dict[last][0]));\n            }\n            output.push.apply(output, dict[code]);\n\n            if (dict.length === (1 << codeSize) && codeSize < 12) {\n                // If we're at the last code and codeSize is 12, the next code will be a clearCode, and it'll be 12 bits long.\n                codeSize++;\n            }\n        }\n\n        // I don't know if this is technically an error, but some GIFs do it.\n        //if (Math.ceil(pos / 8) !== data.length) throw new Error('Extraneous LZW bytes.');\n        return output;\n    };\n\n\n    // The actual parsing; returns an object with properties.\n    var parseGIF = function (st, handler) {\n        handler || (handler = {});\n\n        // LZW (GIF-specific)\n        var parseCT = function (entries) { // Each entry is 3 bytes, for RGB.\n            var ct = [];\n            for (var i = 0; i < entries; i++) {\n                ct.push(st.readBytes(3));\n            }\n            return ct;\n        };\n\n        var readSubBlocks = function () {\n            var size, data;\n            data = '';\n            do {\n                size = st.readByte();\n                data += st.read(size);\n            } while (size !== 0);\n            return data;\n        };\n\n        var parseHeader = function () {\n            var hdr = {};\n            hdr.sig = st.read(3);\n            hdr.ver = st.read(3);\n            if (hdr.sig !== 'GIF') throw new Error('Not a GIF file.'); // XXX: This should probably be handled more nicely.\n            hdr.width = st.readUnsigned();\n            hdr.height = st.readUnsigned();\n\n            var bits = byteToBitArr(st.readByte());\n            hdr.gctFlag = bits.shift();\n            hdr.colorRes = bitsToNum(bits.splice(0, 3));\n            hdr.sorted = bits.shift();\n            hdr.gctSize = bitsToNum(bits.splice(0, 3));\n\n            hdr.bgColor = st.readByte();\n            hdr.pixelAspectRatio = st.readByte(); // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64\n            if (hdr.gctFlag) {\n                hdr.gct = parseCT(1 << (hdr.gctSize + 1));\n            }\n            handler.hdr && handler.hdr(hdr);\n        };\n\n        var parseExt = function (block) {\n            var parseGCExt = function (block) {\n                var blockSize = st.readByte(); // Always 4\n                var bits = byteToBitArr(st.readByte());\n                block.reserved = bits.splice(0, 3); // Reserved; should be 000.\n                block.disposalMethod = bitsToNum(bits.splice(0, 3));\n                block.userInput = bits.shift();\n                block.transparencyGiven = bits.shift();\n\n                block.delayTime = st.readUnsigned();\n\n                block.transparencyIndex = st.readByte();\n\n                block.terminator = st.readByte();\n\n                handler.gce && handler.gce(block);\n            };\n\n            var parseComExt = function (block) {\n                block.comment = readSubBlocks();\n                handler.com && handler.com(block);\n            };\n\n            var parsePTExt = function (block) {\n                // No one *ever* uses this. If you use it, deal with parsing it yourself.\n                var blockSize = st.readByte(); // Always 12\n                block.ptHeader = st.readBytes(12);\n                block.ptData = readSubBlocks();\n                handler.pte && handler.pte(block);\n            };\n\n            var parseAppExt = function (block) {\n                var parseNetscapeExt = function (block) {\n                    var blockSize = st.readByte(); // Always 3\n                    block.unknown = st.readByte(); // ??? Always 1? What is this?\n                    block.iterations = st.readUnsigned();\n                    block.terminator = st.readByte();\n                    handler.app && handler.app.NETSCAPE && handler.app.NETSCAPE(block);\n                };\n\n                var parseUnknownAppExt = function (block) {\n                    block.appData = readSubBlocks();\n                    // FIXME: This won't work if a handler wants to match on any identifier.\n                    handler.app && handler.app[block.identifier] && handler.app[block.identifier](block);\n                };\n\n                var blockSize = st.readByte(); // Always 11\n                block.identifier = st.read(8);\n                block.authCode = st.read(3);\n                switch (block.identifier) {\n                    case 'NETSCAPE':\n                        parseNetscapeExt(block);\n                        break;\n                    default:\n                        parseUnknownAppExt(block);\n                        break;\n                }\n            };\n\n            var parseUnknownExt = function (block) {\n                block.data = readSubBlocks();\n                handler.unknown && handler.unknown(block);\n            };\n\n            block.label = st.readByte();\n            switch (block.label) {\n                case 0xF9:\n                    block.extType = 'gce';\n                    parseGCExt(block);\n                    break;\n                case 0xFE:\n                    block.extType = 'com';\n                    parseComExt(block);\n                    break;\n                case 0x01:\n                    block.extType = 'pte';\n                    parsePTExt(block);\n                    break;\n                case 0xFF:\n                    block.extType = 'app';\n                    parseAppExt(block);\n                    break;\n                default:\n                    block.extType = 'unknown';\n                    parseUnknownExt(block);\n                    break;\n            }\n        };\n\n        var parseImg = function (img) {\n            var deinterlace = function (pixels, width) {\n                // Of course this defeats the purpose of interlacing. And it's *probably*\n                // the least efficient way it's ever been implemented. But nevertheless...\n                var newPixels = new Array(pixels.length);\n                var rows = pixels.length / width;\n                var cpRow = function (toRow, fromRow) {\n                    var fromPixels = pixels.slice(fromRow * width, (fromRow + 1) * width);\n                    newPixels.splice.apply(newPixels, [toRow * width, width].concat(fromPixels));\n                };\n\n                // See appendix E.\n                var offsets = [0, 4, 2, 1];\n                var steps = [8, 8, 4, 2];\n\n                var fromRow = 0;\n                for (var pass = 0; pass < 4; pass++) {\n                    for (var toRow = offsets[pass]; toRow < rows; toRow += steps[pass]) {\n                        cpRow(toRow, fromRow)\n                        fromRow++;\n                    }\n                }\n\n                return newPixels;\n            };\n\n            img.leftPos = st.readUnsigned();\n            img.topPos = st.readUnsigned();\n            img.width = st.readUnsigned();\n            img.height = st.readUnsigned();\n\n            var bits = byteToBitArr(st.readByte());\n            img.lctFlag = bits.shift();\n            img.interlaced = bits.shift();\n            img.sorted = bits.shift();\n            img.reserved = bits.splice(0, 2);\n            img.lctSize = bitsToNum(bits.splice(0, 3));\n\n            if (img.lctFlag) {\n                img.lct = parseCT(1 << (img.lctSize + 1));\n            }\n\n            img.lzwMinCodeSize = st.readByte();\n\n            var lzwData = readSubBlocks();\n\n            img.pixels = lzwDecode(img.lzwMinCodeSize, lzwData);\n\n            if (img.interlaced) { // Move\n                img.pixels = deinterlace(img.pixels, img.width);\n            }\n\n            handler.img && handler.img(img);\n        };\n\n        var parseBlock = function () {\n            var block = {};\n            block.sentinel = st.readByte();\n\n            switch (String.fromCharCode(block.sentinel)) { // For ease of matching\n                case '!':\n                    block.type = 'ext';\n                    parseExt(block);\n                    break;\n                case ',':\n                    block.type = 'img';\n                    parseImg(block);\n                    break;\n                case ';':\n                    block.type = 'eof';\n                    handler.eof && handler.eof(block);\n                    break;\n                default:\n                    throw new Error('Unknown block: 0x' + block.sentinel.toString(16)); // TODO: Pad this with a 0.\n            }\n\n            if (block.type !== 'eof') setTimeout(parseBlock, 0);\n        };\n\n        var parse = function () {\n            parseHeader();\n            setTimeout(parseBlock, 0);\n        };\n\n        parse();\n    };\n\n    var SuperGif = function ( opts ) {\n        var options = {\n            //viewport position\n            vp_l: 0,\n            vp_t: 0,\n            vp_w: null,\n            vp_h: null,\n            //canvas sizes\n            c_w: null,\n            c_h: null\n        };\n        for (var i in opts ) { options[i] = opts[i] }\n        if (options.vp_w && options.vp_h) options.is_vp = true;\n\n        var stream;\n        var hdr;\n\n        var loadError = null;\n        var loading = false;\n\n        var transparency = null;\n        var delay = null;\n        var disposalMethod = null;\n        var disposalRestoreFromIdx = null;\n        var lastDisposalMethod = null;\n        var frame = null;\n        var lastImg = null;\n\n        var playing = true;\n        var forward = true;\n\n        var ctx_scaled = false;\n\n        var frames = [];\n        var frameOffsets = []; // elements have .x and .y properties\n\n        var gif = options.gif;\n        if (typeof options.auto_play == 'undefined')\n            options.auto_play = (!gif.getAttribute('rel:auto_play') || gif.getAttribute('rel:auto_play') == '1');\n\n        var onEndListener = (options.hasOwnProperty('on_end') ? options.on_end : null);\n        var loopDelay = (options.hasOwnProperty('loop_delay') ? options.loop_delay : 0);\n        var overrideLoopMode = (options.hasOwnProperty('loop_mode') ? options.loop_mode : 'auto');\n        var drawWhileLoading = (options.hasOwnProperty('draw_while_loading') ? options.draw_while_loading : true);\n        var showProgressBar = drawWhileLoading ? (options.hasOwnProperty('show_progress_bar') ? options.show_progress_bar : true) : false;\n        var progressBarHeight = (options.hasOwnProperty('progressbar_height') ? options.progressbar_height : 25);\n        var progressBarBackgroundColor = (options.hasOwnProperty('progressbar_background_color') ? options.progressbar_background_color : 'rgba(255,255,255,0.4)');\n        var progressBarForegroundColor = (options.hasOwnProperty('progressbar_foreground_color') ? options.progressbar_foreground_color : 'rgba(255,0,22,.8)');\n\n        var clear = function () {\n            transparency = null;\n            delay = null;\n            lastDisposalMethod = disposalMethod;\n            disposalMethod = null;\n            frame = null;\n        };\n\n        // XXX: There's probably a better way to handle catching exceptions when\n        // callbacks are involved.\n        var doParse = function () {\n            try {\n                parseGIF(stream, handler);\n            }\n            catch (err) {\n                doLoadError('parse');\n            }\n        };\n\n        var doText = function (text) {\n            toolbar.innerHTML = text; // innerText? Escaping? Whatever.\n            toolbar.style.visibility = 'visible';\n        };\n\n        var setSizes = function(w, h) {\n            canvas.width = w * get_canvas_scale();\n            canvas.height = h * get_canvas_scale();\n            toolbar.style.minWidth = ( w * get_canvas_scale() ) + 'px';\n\n            tmpCanvas.width = w;\n            tmpCanvas.height = h;\n            tmpCanvas.style.width = w + 'px';\n            tmpCanvas.style.height = h + 'px';\n            tmpCanvas.getContext('2d').setTransform(1, 0, 0, 1, 0, 0);\n        };\n\n        var setFrameOffset = function(frame, offset) {\n            if (!frameOffsets[frame]) {\n                frameOffsets[frame] = offset;\n                return;\n            }\n            if (typeof offset.x !== 'undefined') {\n                frameOffsets[frame].x = offset.x;\n            }\n            if (typeof offset.y !== 'undefined') {\n                frameOffsets[frame].y = offset.y;\n            }\n        };\n\n        var doShowProgress = function (pos, length, draw) {\n            if (draw && showProgressBar) {\n                var height = progressBarHeight;\n                var left, mid, top, width;\n                if (options.is_vp) {\n                    if (!ctx_scaled) {\n                        top = (options.vp_t + options.vp_h - height);\n                        height = height;\n                        left = options.vp_l;\n                        mid = left + (pos / length) * options.vp_w;\n                        width = canvas.width;\n                    } else {\n                        top = (options.vp_t + options.vp_h - height) / get_canvas_scale();\n                        height = height / get_canvas_scale();\n                        left = (options.vp_l / get_canvas_scale() );\n                        mid = left + (pos / length) * (options.vp_w / get_canvas_scale());\n                        width = canvas.width / get_canvas_scale();\n                    }\n                    //some debugging, draw rect around viewport\n                    if (false) {\n                        if (!ctx_scaled) {\n                            var l = options.vp_l, t = options.vp_t;\n                            var w = options.vp_w, h = options.vp_h;\n                        } else {\n                            var l = options.vp_l/get_canvas_scale(), t = options.vp_t/get_canvas_scale();\n                            var w = options.vp_w/get_canvas_scale(), h = options.vp_h/get_canvas_scale();\n                        }\n                        ctx.rect(l,t,w,h);\n                        ctx.stroke();\n                    }\n                }\n                else {\n                    top = (canvas.height - height) / (ctx_scaled ? get_canvas_scale() : 1);\n                    mid = ((pos / length) * canvas.width) / (ctx_scaled ? get_canvas_scale() : 1);\n                    width = canvas.width / (ctx_scaled ? get_canvas_scale() : 1 );\n                    height /= ctx_scaled ? get_canvas_scale() : 1;\n                }\n\n                ctx.fillStyle = progressBarBackgroundColor;\n                ctx.fillRect(mid, top, width - mid, height);\n\n                ctx.fillStyle = progressBarForegroundColor;\n                ctx.fillRect(0, top, mid, height);\n            }\n        };\n\n        var doLoadError = function (originOfError) {\n            var drawError = function () {\n                ctx.fillStyle = 'black';\n                ctx.fillRect(0, 0, options.c_w ? options.c_w : hdr.width, options.c_h ? options.c_h : hdr.height);\n                ctx.strokeStyle = 'red';\n                ctx.lineWidth = 3;\n                ctx.moveTo(0, 0);\n                ctx.lineTo(options.c_w ? options.c_w : hdr.width, options.c_h ? options.c_h : hdr.height);\n                ctx.moveTo(0, options.c_h ? options.c_h : hdr.height);\n                ctx.lineTo(options.c_w ? options.c_w : hdr.width, 0);\n                ctx.stroke();\n            };\n\n            loadError = originOfError;\n            hdr = {\n                width: gif.width,\n                height: gif.height\n            }; // Fake header.\n            frames = [];\n            drawError();\n        };\n\n        var doHdr = function (_hdr) {\n            hdr = _hdr;\n            setSizes(hdr.width, hdr.height)\n        };\n\n        var doGCE = function (gce) {\n            pushFrame();\n            clear();\n            transparency = gce.transparencyGiven ? gce.transparencyIndex : null;\n            delay = gce.delayTime;\n            disposalMethod = gce.disposalMethod;\n            // We don't have much to do with the rest of GCE.\n        };\n\n        var pushFrame = function () {\n            if (!frame) return;\n            frames.push({\n                            data: frame.getImageData(0, 0, hdr.width, hdr.height),\n                            delay: delay\n                        });\n            frameOffsets.push({ x: 0, y: 0 });\n        };\n\n        var doImg = function (img) {\n            if (!frame) frame = tmpCanvas.getContext('2d');\n\n            var currIdx = frames.length;\n\n            //ct = color table, gct = global color table\n            var ct = img.lctFlag ? img.lct : hdr.gct; // TODO: What if neither exists?\n\n            /*\n            Disposal method indicates the way in which the graphic is to\n            be treated after being displayed.\n\n            Values :    0 - No disposal specified. The decoder is\n                            not required to take any action.\n                        1 - Do not dispose. The graphic is to be left\n                            in place.\n                        2 - Restore to background color. The area used by the\n                            graphic must be restored to the background color.\n                        3 - Restore to previous. The decoder is required to\n                            restore the area overwritten by the graphic with\n                            what was there prior to rendering the graphic.\n\n                            Importantly, \"previous\" means the frame state\n                            after the last disposal of method 0, 1, or 2.\n            */\n            if (currIdx > 0) {\n                if (lastDisposalMethod === 3) {\n                    // Restore to previous\n                    // If we disposed every frame including first frame up to this point, then we have\n                    // no composited frame to restore to. In this case, restore to background instead.\n                    if (disposalRestoreFromIdx !== null) {\n                    \tframe.putImageData(frames[disposalRestoreFromIdx].data, 0, 0);\n                    } else {\n                    \tframe.clearRect(lastImg.leftPos, lastImg.topPos, lastImg.width, lastImg.height);\n                    }\n                } else {\n                    disposalRestoreFromIdx = currIdx - 1;\n                }\n\n                if (lastDisposalMethod === 2) {\n                    // Restore to background color\n                    // Browser implementations historically restore to transparent; we do the same.\n                    // http://www.wizards-toolkit.org/discourse-server/viewtopic.php?f=1&t=21172#p86079\n                    frame.clearRect(lastImg.leftPos, lastImg.topPos, lastImg.width, lastImg.height);\n                }\n            }\n            // else, Undefined/Do not dispose.\n            // frame contains final pixel data from the last frame; do nothing\n\n            //Get existing pixels for img region after applying disposal method\n            var imgData = frame.getImageData(img.leftPos, img.topPos, img.width, img.height);\n\n            //apply color table colors\n            img.pixels.forEach(function (pixel, i) {\n                // imgData.data === [R,G,B,A,R,G,B,A,...]\n                if (pixel !== transparency) {\n                    imgData.data[i * 4 + 0] = ct[pixel][0];\n                    imgData.data[i * 4 + 1] = ct[pixel][1];\n                    imgData.data[i * 4 + 2] = ct[pixel][2];\n                    imgData.data[i * 4 + 3] = 255; // Opaque.\n                }\n            });\n\n            frame.putImageData(imgData, img.leftPos, img.topPos);\n\n            if (!ctx_scaled) {\n                ctx.scale(get_canvas_scale(),get_canvas_scale());\n                ctx_scaled = true;\n            }\n\n            // We could use the on-page canvas directly, except that we draw a progress\n            // bar for each image chunk (not just the final image).\n            if (drawWhileLoading) {\n                ctx.drawImage(tmpCanvas, 0, 0);\n                drawWhileLoading = options.auto_play;\n            }\n\n            lastImg = img;\n        };\n\n        var player = (function () {\n            var i = -1;\n            var iterationCount = 0;\n\n            var showingInfo = false;\n            var pinned = false;\n\n            /**\n             * Gets the index of the frame \"up next\".\n             * @returns {number}\n             */\n            var getNextFrameNo = function () {\n                var delta = (forward ? 1 : -1);\n                return (i + delta + frames.length) % frames.length;\n            };\n\n            var stepFrame = function (amount) { // XXX: Name is confusing.\n                i = i + amount;\n\n                putFrame();\n            };\n\n            var step = (function () {\n                var stepping = false;\n\n                var completeLoop = function () {\n                    if (onEndListener !== null)\n                        onEndListener(gif);\n                    iterationCount++;\n\n                    if (overrideLoopMode !== false || iterationCount < 0) {\n                        doStep();\n                    } else {\n                        stepping = false;\n                        playing = false;\n                    }\n                };\n\n                var doStep = function () {\n                    stepping = playing;\n                    if (!stepping) return;\n\n                    stepFrame(1);\n                    var delay = frames[i].delay * 10;\n                    if (!delay) delay = 100; // FIXME: Should this even default at all? What should it be?\n\n                    var nextFrameNo = getNextFrameNo();\n                    if (nextFrameNo === 0) {\n                        delay += loopDelay;\n                        setTimeout(completeLoop, delay);\n                    } else {\n                        setTimeout(doStep, delay);\n                    }\n                };\n\n                return function () {\n                    if (!stepping) setTimeout(doStep, 0);\n                };\n            }());\n\n            var putFrame = function () {\n                var offset;\n                i = parseInt(i, 10);\n\n                if (i > frames.length - 1){\n                    i = 0;\n                }\n\n                if (i < 0){\n                    i = 0;\n                }\n\n                offset = frameOffsets[i];\n\n                tmpCanvas.getContext(\"2d\").putImageData(frames[i].data, offset.x, offset.y);\n                ctx.globalCompositeOperation = \"copy\";\n                ctx.drawImage(tmpCanvas, 0, 0);\n            };\n\n            var play = function () {\n                playing = true;\n                step();\n            };\n\n            var pause = function () {\n                playing = false;\n            };\n\n\n            return {\n                init: function () {\n                    if (loadError) return;\n\n                    if ( ! (options.c_w && options.c_h) ) {\n                        ctx.scale(get_canvas_scale(),get_canvas_scale());\n                    }\n\n                    if (options.auto_play) {\n                        step();\n                    }\n                    else {\n                        i = 0;\n                        putFrame();\n                    }\n                },\n                step: step,\n                play: play,\n                pause: pause,\n                playing: playing,\n                move_relative: stepFrame,\n                current_frame: function() { return i; },\n                length: function() { return frames.length },\n                move_to: function ( frame_idx ) {\n                    i = frame_idx;\n                    putFrame();\n                }\n            }\n        }());\n\n        var doDecodeProgress = function (draw) {\n            doShowProgress(stream.pos, stream.data.length, draw);\n        };\n\n        var doNothing = function () {};\n        /**\n         * @param{boolean=} draw Whether to draw progress bar or not; this is not idempotent because of translucency.\n         *                       Note that this means that the text will be unsynchronized with the progress bar on non-frames;\n         *                       but those are typically so small (GCE etc.) that it doesn't really matter. TODO: Do this properly.\n         */\n        var withProgress = function (fn, draw) {\n            return function (block) {\n                fn(block);\n                doDecodeProgress(draw);\n            };\n        };\n\n\n        var handler = {\n            hdr: withProgress(doHdr),\n            gce: withProgress(doGCE),\n            com: withProgress(doNothing),\n            // I guess that's all for now.\n            app: {\n                // TODO: Is there much point in actually supporting iterations?\n                NETSCAPE: withProgress(doNothing)\n            },\n            img: withProgress(doImg, true),\n            eof: function (block) {\n                //toolbar.style.display = '';\n                pushFrame();\n                doDecodeProgress(false);\n                if ( ! (options.c_w && options.c_h) ) {\n                    canvas.width = hdr.width * get_canvas_scale();\n                    canvas.height = hdr.height * get_canvas_scale();\n                }\n                player.init();\n                loading = false;\n                if (load_callback) {\n                    load_callback(gif);\n                }\n\n            }\n        };\n\n        var init = function () {\n            var parent = gif.parentNode;\n\n            var div = document.createElement('div');\n            canvas = document.createElement('canvas');\n            ctx = canvas.getContext('2d');\n            toolbar = document.createElement('div');\n\n            tmpCanvas = document.createElement('canvas');\n\n            div.width = canvas.width = gif.width;\n            div.height = canvas.height = gif.height;\n            toolbar.style.minWidth = gif.width + 'px';\n\n            div.className = 'jsgif';\n            toolbar.className = 'jsgif_toolbar';\n            div.appendChild(canvas);\n            div.appendChild(toolbar);\n\n            parent.insertBefore(div, gif);\n            parent.removeChild(gif);\n\n            if (options.c_w && options.c_h) setSizes(options.c_w, options.c_h);\n            initialized=true;\n        };\n\n        var get_canvas_scale = function() {\n            var scale;\n          if (options.max_width && hdr) { // && hdr.width > options.max_width) {\n                scale = options.max_width / hdr.width;\n            }\n            else {\n                scale = 1;\n            }\n            return scale;\n        }\n\n        var canvas, ctx, toolbar, tmpCanvas;\n        var initialized = false;\n        var load_callback = false;\n\n        var load_setup = function(callback) {\n            if (loading) return false;\n            if (callback) load_callback = callback;\n            else load_callback = false;\n\n            loading = true;\n            frames = [];\n            clear();\n            disposalRestoreFromIdx = null;\n            lastDisposalMethod = null;\n            frame = null;\n            lastImg = null;\n\n            return true;\n        }\n\n        return {\n            // play controls\n            play: player.play,\n            pause: player.pause,\n            move_relative: player.move_relative,\n            move_to: player.move_to,\n\n            // getters for instance vars\n            get_playing      : function() { return playing },\n            get_canvas       : function() { return canvas },\n            get_canvas_scale : function() { return get_canvas_scale() },\n            get_loading      : function() { return loading },\n            get_auto_play    : function() { return options.auto_play },\n            get_length       : function() { return player.length() },\n            get_current_frame: function() { return player.current_frame() },\n            load_url: function(src,callback){\n                if (!load_setup(callback)) return;\n\n                var h = new XMLHttpRequest();\n                // new browsers (XMLHttpRequest2-compliant)\n                h.open('GET', src, true);\n\n                if ('overrideMimeType' in h) {\n                    h.overrideMimeType('text/plain; charset=x-user-defined');\n                }\n\n                // old browsers (XMLHttpRequest-compliant)\n                else if ('responseType' in h) {\n                    h.responseType = 'arraybuffer';\n                }\n\n                // IE9 (Microsoft.XMLHTTP-compliant)\n                else {\n                    h.setRequestHeader('Accept-Charset', 'x-user-defined');\n                }\n\n                h.onloadstart = function() {\n                    // Wait until connection is opened to replace the gif element with a canvas to avoid a blank img\n                    if (!initialized) init();\n                };\n                h.onload = function(e) {\n                    if (this.status != 200) {\n                        doLoadError('xhr - response');\n                    }\n                    // emulating response field for IE9\n                    if (!('response' in this)) {\n                        this.response = 0;\n                    }\n                    var data = this.response;\n                    if (data.toString().indexOf(\"ArrayBuffer\") > 0) {\n                        data = new Uint8Array(data);\n                    }\n\n                    stream = new Stream(data);\n                    setTimeout(doParse, 0);\n                };\n                h.onprogress = function (e) {\n                    if (e.lengthComputable) doShowProgress(e.loaded, e.total, true);\n                };\n                h.onerror = function() { doLoadError('xhr'); };\n                h.send();\n            },\n            load: function (callback) {\n                this.load_url(gif.getAttribute('rel:animated_src') || gif.src,callback);\n            },\n            load_raw: function(arr, callback) {\n                if (!load_setup(callback)) return;\n                if (!initialized) init();\n                stream = new Stream(arr);\n                setTimeout(doParse, 0);\n            },\n            set_frame_offset: setFrameOffset\n        };\n    };\n\n    return SuperGif;\n}));\n\n\n","import React, { Component } from 'react';\nimport './Results.css';\nimport PropTypes from 'prop-types';\n\nclass Results extends Component{\n  render() {\n    return (\n      <div className=\"Results\">\n        {this.props.searchResults.map((item, index) => (\n          <img className=\"search-result-gif\"\n            key={index} src={item.images.fixed_height_small.url}\n            onClick={() => this.props.onGifClick(item)} />\n          )\n        )}\n      </div>\n    )\n  }\n};\n\nResults.propTypes = {\n  onGifClick: PropTypes.func.isRequired,\n};\n\nexport default Results;\n","import React, { Component } from 'react';\nimport Results from './Results.js'\nimport PropTypes from 'prop-types';\nimport './searchGiphy.css';\n\nconst searchGifs = (query, callback) => {\n  // http://api.giphy.com/v1/gifs/search?q=funny+cat&api_key=dc6zaTOxFJmzC\n  const giphyApi = {\n    baseUrl: 'http://api.giphy.com',\n    searchEndpoint: '/v1/gifs/search',\n    publicApiKey: 'PrDuQjBTO5H7jg1eO1xj6sx5zGCsi4Y6',\n  }\n  const url = giphyApi.baseUrl + giphyApi.searchEndpoint +\n    '?api_key=' + giphyApi.publicApiKey +\n    '&q=' + query;\n  fetch(url, {cors: 'cors', cache: 'no-cache'})\n    .then((response) => response.json())\n    .then((json) => callback(json['data']));\n};\n\nclass SearchGiphy extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      query: '',\n      loading: false,\n      results: [],\n    }\n    this.queryInput = React.createRef();\n    this.searchTimeoutId = null;\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    if (prevProps.open === this.props.open || !this.props.open) {\n      return;\n    }\n    this.queryInput.current.focus();\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.intervalId);\n  }\n\n  handleSearch = () => {\n    searchGifs(this.state.query, (gifs) => {\n      // redefine our app's state to include populated response\n      this.setState({ results: gifs, loading: false });\n    });\n  }\n\n  handleChange = (event) => {\n    this.setState({ query: event.target.value });\n    if (this.searchTimeoutId === null) {\n      clearTimeout(this.searchTimeoutId);\n    }\n    if (event.target.value !== '') {\n      this.searchTimeoutId = setTimeout(this.handleSearch, 1500);\n      this.setState({ loading: true, });\n    } else {\n      this.setState({ loading: false });\n    }\n  }\n\n  render() {\n    if (!this.props.open) {\n      return '';\n    }\n    return (\n      <div className=\"giphy-search\">\n        <div className=\"search-box\">\n          <input type=\"text\" placeholder={\"enter a search term\"} value={this.state.query}\n            onChange={this.handleChange} ref={this.queryInput} className=\"query-input\"/>\n        </div>\n        <Results searchResults={this.state.query ?\n            this.state.results : this.props.previouslyUsedGifs }\n          onGifClick={this.props.onGifClick}/>\n        <h5 className=\"search-title\">\n          Choose a gif\n          {this.state.loading ? <span className=\"loading\">  loading</span> : \"\"}\n        </h5>\n\n      </div>\n    );\n  }\n}\n\nSearchGiphy.propTypes = {\n  open: PropTypes.bool.isRequired,\n  onGifClick: PropTypes.func.isRequired,\n  closeGifSearch: PropTypes.func,\n};\n\nexport default SearchGiphy;\n","import React, { Component } from 'react';\nimport SuperGif from './libgif.js';\nimport PropTypes from 'prop-types';\n\nclass Gif extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      isReady: false,\n    };\n\n    this.element = React.createRef();\n    this.timeoutId = null;\n  }\n\n  onEnd = () => {\n    if (this.props.duration === 'once') {\n      this.props.onEnd();\n    }\n  }\n\n  componentDidMount() {\n    this.wrapper = new SuperGif({\n      gif: this.element.current,\n      auto_play: this.props.playing,\n      progressbar_height: 0,\n      loop_mode: this.props.loop,\n      on_end: this.onEnd,\n      max_width: this.props.width,\n    });\n    this.wrapper.load(() => this.setState({isReady: true}));\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    if (prevProps.playing === this.props.playing || !this.state.isReady) {\n      if (this.props.playing && !this.timeoutId &&\n        this.props.duration === '5sec') {\n        this.timeoutId =\n          setTimeout(() => {\n            this.props.onEnd();\n            this.timeoutId = null;\n          }, 5000);\n      }\n      return;\n    }\n    if (this.props.playing) {\n      this.wrapper.move_to(0);\n      this.wrapper.play();\n      if (this.props.duration === '5sec' && !this.timeoutId) {\n        this.timeoutId = setTimeout(() => {\n          this.props.onEnd();\n          this.timeoutId = null;\n        }, 5000);\n      }\n    } else {\n      this.wrapper.pause();\n      clearTimeout(this.timeoutId);\n    }\n  }\n\n  render() {\n    if (!this.props.src) {\n      return '';\n    }\n    const src = this.props.src.slice(0, -\"giphy.gif\".length) + '200w.gif';\n    return (\n      <div style={this.props.style} className={this.props.className}>\n        <img ref={this.element} src={src} alt={this.props.alt}\n          width={this.props.width} height=\"auto\" />\n      </div>\n    )\n  }\n}\n\nGif.defaultProps = {\n  autoPlay: false,\n  src: null,\n  style: {},\n  loop: false,\n  width: null,\n  height: null,\n  duration: 'once',\n};\n\nGif.propTypes = {\n  autoPlay: PropTypes.bool,\n  src: PropTypes.string,\n  style: PropTypes.object,\n  loop: PropTypes.bool,\n  width: PropTypes.number,\n  height: PropTypes.number,\n  duration: PropTypes.string,\n};\n\nexport default Gif;\n","import React from 'react';\nimport Gif from './Gif';\nimport PropTypes from 'prop-types';\n\nclass GifDisplay extends React.Component {\n  render() {\n    if (!this.props.gif) {\n      return \"\";\n    }\n    return (\n      <Gif className=\"gif-player\" src={this.props.gif.url} alt=\"gif\"\n        style={{left: this.props.gif.positionX,\n          width: this.props.width,\n          top: this.props.gif.positionY,\n          visibility: this.props.playing ? 'visible' : 'hidden',\n        }}\n        playing={this.props.playing} duration={this.props.gif.duration}\n        width={this.props.width} loop={this.props.gif.duration!=='once'}\n        onEnd={this.props.onEnd}\n      />\n    );\n  }\n};\n\nGifDisplay.propTypes = {\n  playing: PropTypes.bool,\n  gif: PropTypes.object.isRequired,\n  width: PropTypes.number.isRequired,\n}\n\nexport default GifDisplay;\n","import React from 'react';\nimport './GifBar.css';\n\nclass GifBar extends React.Component {\n  render() {\n    return (\n      <div className=\"gif-bar\">\n        { this.props.showMarkers ?\n            this.props.gifs.map((gif) =>\n              <div className=\"gif-marker\" key={gif.url+gif.timeFraction}\n                style={{marginLeft: gif.timeFraction*100 + \"%\"}} />)\n          : ''\n        }\n      </div>);\n  }\n};\n\nexport default GifBar;\n","export const SERVER_ADDRESS = \"http://gif-backend.herokuapp.com\";\nexport const VIDEO_INFO_ADDRESS = \"http://noembed.com/embed?url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3D\";\n","import React, { Component } from 'react';\nimport { VIDEO_INFO_ADDRESS } from '../constants';\nimport './VideosListElement.css';\n\nclass PopulatedVideoInfo extends Component {\n  render() {\n    return (\n      <div className='video-info'\n        style={{backgroundImage: 'url('+this.props.videoInfo.thumbnail_url+')'}}\n        onClick={() => { window.location = '?id='+this.props.videoId; }}>\n        <span>\n          {this.props.videoInfo.title}\n        </span>\n      </div>\n    );\n  }\n}\n\nclass VideosListElement extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      videoInfo: null,\n      loading: true,\n    };\n  }\n\n  componentDidMount() {\n    fetch(VIDEO_INFO_ADDRESS + this.props.videoId)\n      .then(response => response.json())\n      .then(json => this.setState({videoInfo: json, loading: false}));\n  }\n\n  render() {\n    if (!this.state.loading && this.state.videoInfo.error) {\n      return '';\n    }\n    return this.state.loading ?\n      <div className='video-info'>Loading</div> :\n      <PopulatedVideoInfo videoInfo={this.state.videoInfo}\n        videoId={this.props.videoId}/>;\n  }\n}\n\nexport default VideosListElement;\n","import React, { Component } from 'react';\nimport './VideosList.css';\nimport VideosListElement from './VideosListElement';\nimport { SERVER_ADDRESS } from '../constants';\n\nclass VideosList extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      loading: true,\n      videoIds: []\n    };\n  }\n\n  componentDidMount() {\n    fetch(SERVER_ADDRESS+'/videos')\n      .then(response => response.json())\n      .then(json => {\n        this.setState({\n          videoIds: Array.from(new Set(\n            json.map((video) => video.videoId).filter(x => x))),\n          loading: false,\n        });\n      });\n  }\n\n  hideList = (e) => {\n    e.preventDefault();\n    if (this.props.onHide) {\n      this.props.onHide();\n    }\n  }\n\n  render() {\n    return (\n      <div className='videos-list'\n        style={{visibility: !this.props.visible && 'hidden'}}>\n        <button href=\"#\" onClick={this.hideList} className=\"hide-link\">\n          Hide\n        </button>\n        {this.state.loading && <div className=\"results-loading\">Loading</div>}\n        {this.state.videoIds.map((videoId) =>\n          <VideosListElement videoId={videoId} />)\n        }\n      </div>\n    );\n  }\n}\n\nexport default VideosList;\n","import React, { Component } from 'react';\nimport YouTube from 'react-youtube';\nimport './App.css';\nimport ReactDOM from 'react-dom';\nimport SearchGiphy from './components/searchGiphy.js'\nimport GifDisplay from './components/GifDisplay';\nimport GifBar from './components/GifBar';\nimport VideosList from './components/VideosList';\nimport {Rnd} from 'react-rnd';\nimport { SERVER_ADDRESS, VIDEO_INFO_ADDRESS } from './constants';\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = { \n      gifs: [],\n      videoId: this.props.urlParams.get(\"id\"),\n      videoInfo: null,\n      videoDuration: null,\n      videoPlaying: false,\n      newGif: null,\n      newGifX: 0, newGifY: 0,\n      newGifSize: {width: false, height: false},\n      newGifDuration: 'once',\n      previouslyUsedGifs: JSON.parse(localStorage.getItem(\"usedGifs\")) || [],\n      showGifSearch: false,\n      showAddGif: false,\n      showGifBar: true,\n      showVideosList: false,\n    };\n\n    this.player = React.createRef();\n    this.searchDiv = React.createRef();\n    this.newGifRnd = React.createRef();\n\n    document.addEventListener('mousedown', this.handleDocumentClick, false);\n    document.addEventListener('keydown', this.handleEsc, false);\n    window.addEventListener('resize', this.onWindowResize, false);\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener('mousedown', this.handleDocumentClick, false);\n    document.removeEventListener('keydown', this.handleEsc, false);\n    window.removeEventListener('resize', this.onWindowResize, false);\n    clearInterval(this.intervalId);\n  }\n\n  componentDidMount() {\n    if (!this.state.videoId) {\n      window.location = '?id=dQw4w9WgXcQ';\n      return;\n    }\n    fetch(SERVER_ADDRESS+'/videos', {\n      method: 'post', cache: 'no-cache', cors: 'cors',\n      headers: { \"Content-Type\": \"application/json; charset=utf-8\", },\n      body: JSON.stringify({videoId: this.state.videoId}),\n    });\n    fetch(VIDEO_INFO_ADDRESS+this.state.videoId)\n      .then(response => response.json())\n      .then(json => this.setState({videoInfo: json}));\n  }\n\n  handleEsc = (event) => {\n    if (event.key === \"Escape\") {\n      this.setState({showGifSearch: false});\n    }\n  }\n\n  handleDocumentClick = (event) => {\n    if (!this.state.videoId) {\n      return;\n    }\n    if (!this.showGifSearch || this.searchDiv.current.contains(event.target)) {\n      return;\n    }\n    this.setState({showGifSearch: false});\n  }\n\n  serverGifToLocal = (gif) => {\n    return {\n      url: gif.gifId,\n      timeFraction: gif.timestamp,\n      fracX: gif.fracX, fracY: gif.fracY,\n      serverId: gif._id, scale: gif.scale,\n      duration: gif.duration,\n    };\n  }\n\n  fetchGifs = () => {\n    return fetch(SERVER_ADDRESS+'/gifs?videoId='+this.state.videoId)\n      .then((response) => response.json())\n      .then((json) => json.gifs.map(this.serverGifToLocal));\n  }\n\n  getVideoDuration = (callback) => {\n    return this.player.current.internalPlayer.getDuration();\n  }\n\n  onPlayerReady = () => {\n    this.intervalId = setInterval(this.timer, 100);\n    Promise\n      .all([this.fetchGifs(), this.getVideoDuration()])\n      .then(([gifs, duration]) => {\n        this.setState({\n          gifs: (this.computeGifPositions(gifs)\n            .sort((a, b) => (a.timeFraction - b.timeFraction))),\n          videoDuration: duration,\n        })\n      });\n  }\n\n  onPlayerStateChange = (event) => {\n    if (event.data === 1) { // playing\n      this.setState({videoPlaying: true});\n      clearTimeout(this.gifBarTimeoutId);\n      this.gifBarTimeoutId = setTimeout(\n        () => this.setState({showGifBar: false}), 4000);\n    } else {\n      this.setState({showGifBar: true, videoPlaying: false});\n      clearTimeout(this.gifBarTimeoutId);\n    }\n  }\n\n  onMouseMove = (event) => {\n    if (!this.state.videoPlaying) {\n      return;\n    }\n    clearTimeout(this.gifBarTimeoutId);\n    this.setState({showGifBar: true});\n    this.gifBarTimeoutId = setTimeout(\n        () => this.setState({showGifBar: false}), 2000);\n  }\n\n  timer = () => {\n    try {\n    this.player.current.internalPlayer\n      .getCurrentTime()\n      .then((time) => {\n        this.setState({currentVideoTime: time})\n        this.setState(({gifs, videoDuration}) => {\n          let anythingChanged = false;\n          const newGifs = gifs.map((gif) => {\n            if (Math.abs(time - gif.timeFraction*videoDuration) < 0.15) {\n              anythingChanged = true;\n              return Object.assign(gif, {playing: true})\n            }\n            return gif;\n          })\n          if (anythingChanged) { return { gifs: newGifs }; }\n        });\n      });\n    } catch (e) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  gifEnded = (gif) => {\n    this.setState(({gifs}) => {\n      const gif_index = gifs.findIndex(stateGif =>\n        stateGif.url === gif.url && stateGif.timeFraction === gif.timeFraction);\n      if (gif_index === -1) {\n        return gifs;\n      }\n      return {gifs: [\n        ...gifs.slice(0, gif_index),\n        Object.assign(gif, {playing: false}),\n        ...gifs.slice(gif_index+1)\n      ]};\n    });\n  }\n\n  toggleGifSearch = () => {\n    this.setState(({showGifSearch}) => ({showGifSearch: !showGifSearch}));\n  }\n  closeGifSearch = () => { this.setState({showGifSearch: false}); }\n  handleCancel = () => { this.setState({newGif: null, showGifSearch: false}); }\n\n  addNewGif = (gif) => {\n    this.setState(({previouslyUsedGifs}) => {\n      if (previouslyUsedGifs.includes(gif)) {\n        return { newGif: gif, showGifSearch: false };\n      } else {\n        return { newGif: gif, showGifSearch: false,\n          previouslyUsedGifs: [gif, ...previouslyUsedGifs]};\n      }\n    }, () => localStorage.setItem(\"usedGifs\",\n      JSON.stringify(this.state.previouslyUsedGifs)));\n    this.player.current.internalPlayer.pauseVideo();\n  }\n\n  postNewGif = (gifInfo) => {\n    fetch(SERVER_ADDRESS+'/gifs', {\n      method: 'post', cache: 'no-cache', cors: 'cors',\n      headers: { \"Content-Type\": \"application/json; charset=utf-8\", },\n      body: JSON.stringify({videoId: gifInfo.videoId,\n        gifId: gifInfo.url, gifTimestamp: gifInfo.timeFraction,\n        fracX: gifInfo.fracX, fracY: gifInfo.fracY, scale: gifInfo.scale,\n        duration: gifInfo.duration,\n      }),\n    });\n  }\n\n  getRealVideoDimensions = () => {\n    const videoRect = ReactDOM.findDOMNode(this.player.current).children[0]\n      .getBoundingClientRect();\n    const scale = Math.min(videoRect.width / this.state.videoInfo.width,\n      videoRect.height / this.state.videoInfo.height);\n    return { width: scale*this.state.videoInfo.width,\n      height: scale*this.state.videoInfo.height };\n  }\n\n  computeGifPositions = (gifList) => {\n    const realDimensions = this.getRealVideoDimensions();\n    const videoRect = ReactDOM.findDOMNode(this.player.current).children[0]\n      .getBoundingClientRect();\n    return gifList.map(gif => {\n      const positionX = Math.min(\n        Math.max(gif.fracX*realDimensions.width+videoRect.width/2, 0),\n        videoRect.width-100);\n      const positionY = Math.min(\n        Math.max(gif.fracY*realDimensions.height+videoRect.height/2, 0),\n        videoRect.height-100);\n      return {...gif, positionX, positionY};\n    });\n  }\n\n  updateGifPositions = () => {\n    this.setState(({gifs}) => ({ gifs: this.computeGifPositions(gifs) }));\n  }\n\n  onWindowResize = () => { this.updateGifPositions(); }\n\n  saveNewGif = () => {\n    const gif = this.state.newGif;\n    const url = `https://media.giphy.com/media/${gif.id}/giphy.gif`;\n    const time = this.state.currentVideoTime;\n    const videoId = this.state.videoId;\n    const realDimensions = this.getRealVideoDimensions();\n    const videoRect = ReactDOM.findDOMNode(this.player.current).children[0]\n      .getBoundingClientRect();\n    const fracX = (this.state.newGifX - videoRect.width/2) / realDimensions.width;\n    const fracY = (this.state.newGifY - videoRect.height/2) / realDimensions.height;\n    const scale = this.newGifRnd.current.getBoundingClientRect().width /\n      realDimensions.width;\n    const duration = this.state.newGifDuration;\n    const toSave = {url, time, videoId, fracX, fracY, scale, duration,\n      positionX: this.state.newGifX,\n      positionY: this.state.newGifY,\n      timeFraction: time/this.state.videoDuration,\n    };\n    this.postNewGif(toSave);\n    this.setState({\n      gifs: this.state.gifs.concat([toSave]),\n      newGif: null,\n      newGifX: 0, newGifY: 0,\n      newGifSize: {width: false, height: false},\n      newGifDuration: 'once',\n    });\n  }\n\n  render() {\n    if (this.state.videoId === null) {\n      return (\n        <div className=\"App\">\n          Please enter video id in the url.\n          Like this: <a href='?id=dQw4w9WgXcQ'>?id=dQw4w9WgXcQ</a>.\n        </div>\n      );\n    }\n    return (\n      <div className=\"App container\">\n        <VideosList onHide={() => this.setState({showVideosList: false})}\n          visible={this.state.showVideosList} />\n        <div className=\"header\">\n          <h1>Gifgif</h1>\n          <button className=\"show-videos-list\"\n            onClick={() => this.setState({showVideosList: true})}>\n            Other videos\n          </button>\n          {this.state.newGif ?\n              <button type=\"button\" className=\"btn btn-success save-gif-button\"\n                onClick={this.saveNewGif}>\n                Save\n              </button> \n              : ''\n          }\n          {this.state.showGifSearch || this.state.newGif ?\n              <button type=\"button\" className=\"btn btn-danger add-gif-button\"\n                onClick={this.handleCancel}>\n                Cancel\n              </button> :\n              <button type=\"button\" className=\"btn btn-primary add-gif-button\"\n                onClick={this.toggleGifSearch}>\n                Add gif\n              </button>\n          }\n          {this.state.newGif &&\n              <div className=\"choose-duration\">\n                <span className=\"play-label\">\n                  Choose place and time for the gif. Play gif</span>\n                <div className=\"btn-group btn-group-toggle\" data-toggle=\"buttons\">\n                  <button className={\"btn btn-sm btn-primary \"\n                      +(this.state.newGifDuration==='once' ? \"active\" : \"\")}\n                      onClick={()=>this.setState({newGifDuration: 'once'})}>\n                      once\n                    </button>\n                    <button className={\"btn btn-sm btn-primary\"\n                        +(this.state.newGifDuration!=='once' ? \" active\" : \"\")}\n                        onClick={()=>this.setState({newGifDuration: '5sec'})}>\n                        for 5 seconds\n                      </button>\n                    </div>\n                  </div>\n          }\n        </div>\n        <div className=\"videoFrame\" onMouseMove={this.onMouseMove}>\n          <YouTube videoId={this.state.videoId}\n            opts={{width: '100%', height: '100%', playerVars: {autoplay: 1}}}\n            ref={this.player} onReady={this.onPlayerReady}\n            onStateChange={this.onPlayerStateChange} />\n          {this.state.newGif && <div className=\"protective-screen\"/>}\n          {this.state.newGif ?\n              <Rnd bounds=\"parent\" lockAspectRatio={true}\n                onDragStop={(e, d) => this.setState({newGifX: d.x, newGifY: d.y})}\n                onResize={(e,d,ref) =>\n                    this.setState({newGifSize: ref.getBoundingClientRect()})}>\n                <img src={this.state.newGif.images.fixed_height_small.url}\n                  style={{width: this.state.newGifSize.width || \"100%\",\n                    height: this.state.newGifSize.height || \"100%\"\n                  }} ref={this.newGifRnd} />\n              </Rnd>\n              : ''\n          }\n          <GifBar gifs={this.state.gifs} showMarkers={this.state.showGifBar}/>\n          <div ref={this.searchDiv}>\n            <SearchGiphy onGifClick={this.addNewGif}\n              previouslyUsedGifs={this.state.previouslyUsedGifs}\n              open={this.state.showGifSearch} closeGifSearch={this.closeGifSearch}/>\n          </div>\n          {this.state.gifs.map(gif =>\n            <GifDisplay gif={gif} key={gif.url+gif.timeFraction}\n              width={gif.scale*this.getRealVideoDimensions().width || 200}\n              playing={gif.playing} onEnd={() => this.gifEnded(gif)}/>)}\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import 'bootstrap/dist/css/bootstrap.min.css';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nconst urlParams = new URLSearchParams(window.location.search);\nReactDOM.render(<App urlParams={urlParams} />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}